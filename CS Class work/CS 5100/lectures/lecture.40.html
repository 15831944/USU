<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>CS  5100 Lecture 40 - Greg Jones</TITLE>
</HEAD>
<BODY>

<B><I><FONT SIZE=5><P>Activex                                        &#9;&#9;&#9;&#9;&#9;Lecture 5100.40</P>
<OL TYPE="A">

</I></FONT><LI>Background</LI>
<OL>

<LI>Historically, there has been a progression through:</LI>
<OL TYPE="a">

<LI>Clipboard</LI>
<LI>DDE (Dynamic Data Exchange)</LI>
<LI>OLE1</LI>
<LI>OLE2</LI>
<LI>OLE/COM</LI>
<LI>ActiveX</LI>
<LI>Active technologies</LI></OL>

<LI>OLE and COM expanded to the point that they deserved a new name,  ActiveX.</LI>
<LI>The "X" refers to the fact that we transfer data and  behavior, and the "Active" refers to the fact that these transfers  happen on the fly.</LI>
<LI>The major benefit is that the system allows real-time, concurrent message passing between applications which may never  have heard of each other previously.</LI></OL>

<LI>ActiveX Categories</LI>
<OL>

<LI>ActiveX Servers and Controls are an extension of the OLE capabilities.  They are often referred to as Automation servers.  They extend the static documents of OLE to include a user interface.  They serve the same need as the older Virtual Basic (VBX) controls and OCX controls.  In fact, the file type of an ActiveX control is OCX.  They are competitors to Java applets.  They typically provide property pages to allow users to customize their appearance and behavior.</LI>
<LI>ActiveX containers are simply applications which are able to embed or link to an ActiveX object.  They provide the platform for displaying, editing, or generally using the object.  Through the use of stock and ambient properties, they allow the control to blend in with the appearance and needs of the container.</LI>
<LI>ActiveX servers allow themselves to be called as a whole to permit users of containers to work with the objects (documents) they support.</LI>
<LI>ActiveX automation servers expose, via the COM model, the public properties and methods of an ActiveX object.  In effect, this provides the same function as dynamically importing a Java package, and is somewhat similar to including the header file for a C++ class.  Through COM, however, the whole process is binary, and not dependent on any single language.</LI>
<LI>It probably originated with the desire to use Visual C++ elements in applications written in other languages.  The principle is to provide reusable modules to users and programmers in languages which may not support the intricate behavior of Visual C++.  Usually these will be Visual Basic users.</LI>
<LI>An ActiveX automation server goes beyond allowing itself to be launched to deal with an embedded or linked document.  It actually exposes its individual methods for use elsewhere, as would a DLL.  For instance, it may provide a function to resize columns, which could be used by any application which needs to do that.</LI>
<LI>ActiveX controls are small, extremely rapid ActiveX automation servers which load at runtime, like Java classes.</LI></OL>

<LI>ActiveX Mechanisms</LI>
<OL>

<LI>Containers usually interact as drop targets, using standard data formats and depending on standard OLE functions to deliver data.  They work through OnDragEnter, OnDrop, etc.</LI>
<LI>ActiveX servers respond to launch commands.  For instance, an MDI server would be run when an object it serves is triggered in a container.  If it were already running, it would simply display another view with the object in it.</LI>
<LI>ActiveX automation servers use dispatch maps and interface maps to go beyond providing themselves as an entire launchable application.  They actually permit the container to call specific member functions and modify specific properties which are data members of their classes.  In addition, they maintain reference counts, so that they do not exit when one container no longer is using them but another is still doing so.  Typically, they do not have their own main window.</LI>
<OL TYPE="a">

<LI>Dispatch maps show how to transmit property/method requests to the automation server.  </LI>
<LI>Interface maps generate the COM information necessary to inform the container of what the methods and properties are.</LI></OL>

<LI>ActiveX controls are automation servers which also expose events.  This means that events generated by the user’s actions within the control can be propagated back to the container to influence its behavior.</LI>
<LI>An ActiveX control’s event map informs of what events, generated within the control, can be caught by the container.</LI></OL>

<LI>Generally speaking, a programmer depends heavily on the AppWizard to generate most of the infrastructure of ActiveX code.</LI>
<OL>

<LI>For a container, choose compound document support:container.</LI>
<LI>For a server, choose compound document support:full server.</LI>
<LI>For an automation server, do not select compound document support, but instead click on Automation support.</LI>
<LI>In the case of controls, there is a separate MFCActiveXControlWizard</LI></OL>

<LI>Sample Clock ActiveX Control</LI>
<OL>

<LI>In Visual C++, File, New, MFCActiveXControlWizard</LI>
<OL TYPE="a">

<LI>First page leave defaults</LI>
<LI>Second page, select &quot;Available in ‘Insert object’ dialog&quot;, Finish</LI></OL>

<LI>Add the &quot;Time&quot; property</LI>
<OL TYPE="a">

<LI>Class Wizard for the Ctrl class, Automation tab</LI>
<LI>AddProperty (Time, CString, m_time), OK</LI>
<LI>Go to the DoPropExchange function where initialization occurs and add&#9;&#9;PX_String(pPX, &quot;Time&quot;, m_time, &quot;January 1, 1900  00:00:00&quot;);</LI>
<LI>Go to the OnDraw function and replace the Ellipse() with&#9;&#9;&#9;&#9;&#9;pDC-&gt;ExtTextOut(0,0,ETO_OPAQUE, rcBounds, m_time, NULL);</LI>
<LI>Build the control</LI></OL>

<LI>From the Tools menu select ActiveX Test Container, Edit, Insert Control, select your control</LI>
<LI>Now in order to update the clock</LI>
<OL TYPE="a">

<LI>Class Wizard, ActiveX Events tab</LI>
<LI>Add Event which you name Click, OK</LI>
<LI>Message Maps tab, WM_LBUTTONDOWN, Add Function, Edit</LI>
<LI>Add the following code&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;CTime time = CTime::GetCurrentTime();&#9;&#9;&#9;&#9;&#9;&#9;m_time = time.Format(&quot;%B, %d, %Y  %I:%M:%S&quot;);&#9;&#9;&#9;&#9;&#9;InvalidateControl();</LI>
<LI>Rebuild control</LI></OL>

<LI>Delete first control from Test Container, insert again, test that clicking updates time</LI>
<LI>Run Word, Insert, Object, select your control, try it out</LI>
<LI>Now to set a property which will display time in military or civilian format</LI>
<OL TYPE="a">

<LI>Project View, Resource tab, open resource editor for prop page, add a checkbox</LI>
<LI>Class Wizard, Automation tab, Add Property,(&quot;Military&quot;, BOOL, m_military)</LI>
<LI>Member Variable tab, Add variable (m_military, BOOL, Optional Property Name is Military)</LI>
<LI>In OnLButtonDown, use m_military to choose the %H instead of %I format specifier</LI>
<LI>Rebuild control</LI></OL>

<LI>In the Test Container, delete the old object, insert the new, Edit,Properties, check the box</LI>
<LI>In Word, delete the old object, insert the new, Edit, Object, Properties</LI>
<LI>Delete the object from the Test Container, File, Register Controls, select your control, Unregister</LI></OL>
</OL>
</B></BODY>
</HTML>
