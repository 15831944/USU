<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>CS  5100 Lecture 39 - Greg Jones</TITLE>
</HEAD>
<BODY>

<B><I><FONT SIZE=5><P>OLE &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Lecture 5100.39</P>
<OL TYPE="A">

</I></FONT><LI>Object Linking and Embedding</LI>
<OL>

<LI>The idea is to reference (linking) or incorporate (embedding) one "document" within another.</LI>
<OL TYPE="a">

<LI>References or pointers to other documents are used for linking.  If the separate document changes, then the view of it in the container changes immediately.</LI>
<LI>Documents can also be incorporated, which means that a copy of the document as it now exists is embedded.  If the original document changes, this is not seen in the embedded version.</LI></OL>

<LI>An OLE container is the application whose documents can refer to or embed others</LI>
<LI>An OLE server is the application which can display or modify the embedded/linked document.</LI>
<LI>This is somewhat similar to the document/view dichotomy.  The container represents the document, while the server represents the view.</LI>
<LI>The value of OLE software development</LI>
<OL TYPE="a">

<LI>Building a container means that we don't have to create the functionality needed to view all the data contained.</LI>
<LI>Building a server means that we can charge people for the use of our software.  It becomes a specialized way of building and displaying certain kinds of data.</LI></OL>

<LI>This makes for building-block software development, specialization, and document centered organization, in which it is the logical unity of the document which matters, not the particular format (text, bitmap, spreadsheet) in which parts of it may be written.</LI>
<LI>Clipboard and Drag-and-Drop are handy mechanisms for object embedding.  By default, they both work on the embedding model.</LI></OL>

<LI>The Component Object Model</LI>
<OL>

<LI>This is a binary standard for describing objects.  In other words, an object coded in C++ or Java should have the same COM description.  It provides a language-independent way of working with objects.</LI>
<OL TYPE="a">

<LI>Identity is provided by registered identifiers, called GUID  (globally unique ID) attributes.</LI>
<LI>COM components have state.  The only data member that is absolutely required is a count of how many clients are currently using the component.</LI>
<LI>The behavior of a component is exposed through its interface.</LI>
<OL TYPE="i">

<LI>In order to facilitate forward and backward compatibility with clients expecting newer or older versions of the component, this interface can be determined dynamically.  </LI>
<LI>These interfaces list no data members and only pure virtual functions.  In other words, they are Java interfaces.</LI>
<LI>COM applications first communicate through standard interfaces which are understood by any COM application.  Every COM application implements the IUnknown interface, which allows another application to discover additional interfaces.  This interface serves to permit inquiry about other interfaces that may be implemented by the object.</LI></OL>

<LI>Because interfaces are abstract, COM supports polymorphism.</LI>
<LI>COM also provides a technique for inheritance.</LI></OL>

<LI>The development of COM has largely been driven by market forces and competition.  It has not been a planned development and demonstrates a great deal of complexity and confusion.  Development was spurred by the success of Visual Basic, products from Borland, web and Java successes, and a desire to squash Sun and the Netscape Navigator.</LI>
<LI>In the end, COM provides a way to share code in small packages and in a highly dynamic fashion without revealing proprietary source code.</LI>
<LI>Specific COM implementation facets include:</LI>
<OL TYPE="a">

<LI>The COM server developed by the component developer.  This server provides</LI>
<LI>The COM class factory, which satisfies the communication needs of</LI>
<LI>The Windows COM system, which provides the connections between COM clients and servers.  Specifically, it delivers interface information when presented with a GUID.  The information is accessed by way of a pointer generated by the class factory.  The COM system also loads and removes COM components using</LI>
<LI>The reference count of current clients.  This is incremented by the COM component each time an interface is requested by a client, and decremented by the client by way of a Release when it is finished with the interface pointer.</LI></OL>
</OL>

<LI>A Simple OLE drag and drop application.</LI>
<OL>

<LI>Create a new single-document-interface project with compound document (container) support.</LI>
<LI>In the view class definition, declare a COleDropTarget object, then register it in the view’s OnCreate.</LI>
<LI>In the view class, override</LI>
<OL TYPE="a">

<LI>OnDragOver to return a DROPEFFECT object with value DROPEFFECT_COPY.</LI>
<LI>OnDragEnter to return the value of OnDragOver.</LI>
<LI>OnDragLeave to return the value of the base class OnDragLeave.</LI>
<LI>OnDrop to</LI>
<OL TYPE="i">

<LI>&#9;Create a STGMEDIUM structure.  This will hold a description of the storage medium holding the data to be accepted.</LI>
<LI>&#9;Call pDataObject-&gt;GetData(CF_TEXT, &amp;struc), which will load the structure with information about the text object dropped</LI>
<LI>Use  (const char **)struc.hGlobal as the text of the drop.</LI>
<LI>&#9;Call ReleaseStgMedium(&amp;struc) to free the allocated memory for the storage medium.  This is not strictly necessary in this example, since the created structure would be released anyway upon return from OnDrop.  However, in other cases, where the storage medium is a parameter, failure to release it would cause a memory leak.</LI></OL>

<LI>&#9;In some cases, we might want to deal with data drops which might not be text.  For instance, if we expected a file drag, we would</LI>
<OL TYPE="i">

<LI>Test to see if struc.tymed is NULL, which would indicate that the drop object isn’t in the CF_TEXT format.</LI>
<LI>Try pDataObject-&gt;GetData(CF_HDROP, &amp;struc) to see if it is a file.</LI>
<LI>&#9;Create a drop handle with HDROP hdrop = (HDROP)GlobalLock(struc.hGlobal).</LI>
<LI>&#9;Get the file name with int i = DragQueryFile(hdrop, 0, buffer, 99).</LI>
<LI>&#9;&#9;Release the drop handle with GlobalUnlock(hdrop).</LI></OL>
</OL>
</OL>
</OL>
</B></BODY>
</HTML>
