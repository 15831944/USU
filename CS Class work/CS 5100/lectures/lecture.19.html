<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>CS 5100 Lecture 19 - Greg Jones</TITLE>
<META NAME="Template" CONTENT="C:\Program Files\Microsoft Office\Templates\Lecture.dot">
</HEAD>
<BODY>

<B><I><FONT SIZE=5><P>The Java 1.1 Event Model&#9;&#9;&#9;&#9;&#9;&#9;&#9;Lect5100.19</P>
<OL TYPE="A">

</I></FONT><LI>Event-Driven Programming</LI>
<OL>

<LI>We are often introduced to programming using simple data-flow structured applications.</LI>
<OL TYPE="a">

<LI>This means that they expect the input of certain data, and then produce the corresponding output.</LI>
<LI>There is never much doubt what the program will do next, as the programmer, through the program as surrogate, is in total control of the processing sequence.</LI>
<LI>Users view this as inflexible, or even dictatorial.  They want to be able to choose to do what they want, when they want.</LI></OL>

<LI>In event-driven programming, the user is encouraged to generate specific events that will guide the processing sequence.</LI>
<OL TYPE="a">

<LI>These events are usually generated by means of mouse and key actions, frequently by pushing buttons, selecting menu entries, scrolling, and list selection.</LI>
<LI>The programmer no longer prepares a sequence of algorithms, using control structures, which will unwind in a predictable fashion.  Instead, the programmer writes many short methods that respond to the atomic actions taken by the user.</LI>
<LI>For those interested in Design Patterns, this represents a Reactor Pattern, in which one entity is observable, generating events, and another is the observer, responding to the events.</LI></OL>

<LI>This separation of the observable graphical user interface from the observing action implementations promotes reusability.  A good interface element can be linked to many different actions in different applications, and a good action can likewise be linked to many different interface components.</LI></OL>

<LI>The Java Event Model</LI>
<OL>

<LI>Events are most often considered to represent some external physical action, like a key press or move movement.  However, a single event, like moving a mouse into a component, might generate multiple events, indicating mouse motion and gaining focus.</LI>
<LI>There is a java.util.EventObject class which is the base for all events, whether related to GUI components or not.  A subclass of this is java.awt.AWTEvent. Specific GUI event classes, like PaintEvent or TextEvent, are found in the java.awt.event package.</LI>
<LI>There is an outdated Java 1.0 event model, which we will ignore.  It essentially uses the object itself instead of a listener.  </LI>
<LI>In the Java 1.1 model, the base event class for GUI components is called AWTEvent.</LI>
<OL TYPE="a">

<LI>Events are true objects.  Each one has fields which give information about the event that has occurred.  Each event has a source field, identifying the object where the event occurred and methods to get the source and generate a string describing the event object.</LI>
<LI>AWTEvent is extended to focus events, window events, mouse events, etc. </LI>
<LI>AWTEvent fields: </LI>
<OL TYPE="i">

<LI>consumed tells whether the event has been consumed by another Listener method</LI>
<LI>id gives the constant id number which identifies which subclass event has occurred</LI>
<LI>RESERVED_ID_MAX gives the maximum integer id number reserved to the system.  Custom events can be created by extending AWTEvent and using id numbers larger than this one.</LI></OL>

<LI>AWTEvent Methods</LI>
<OL TYPE="i">

<LI>getID returns the id of the event</LI>
<LI>consume, isConsumed set and report the consumed variable</LI>
<LI>paramString, toString create strings describing the event’s state</LI></OL>
</OL>

<LI>In the Java 1.2 model, the AWT events continue to be basic, but there is an additional and extensive repertoire of Swing events.  They are usually derived directly from java.util.EventObject, although a few derive from AWTEvent.  In part these are customized to the Swing components, and in part they specialize existing AWT events.  Some Swing events are generated by changes in data models associated with components rather than events in the components themselves.  Because Swing events are specialized they have no id field.</LI>
<LI>There are also classes of events that don’t relate directly to GUI components.</LI>
<LI>Events are generally classified as component or semantic.</LI>
<OL TYPE="a">

<LI>Component events are the standard events that can happen in specific GUI components.  These would include things like mouse, key, and window events.  They have the same meaning in all component classes in which they occur.  Since they are so basic, they are often described as low-level.</LI>
<LI>Semantic events are those that have specific meaning in only some components, like text events, or those which have different meaning, depending on the type of component where the event occurred.  An example of the second might be an action event, which would have different meaning in a text field (typing complete) than on a list (execute a program).</LI></OL>
</OL>

<LI>The Event Processing Sequence</LI>
<OL>

<LI>User performs an action.</LI>
<LI>The platform’s native peer detects the action on the peer, and calls an appropriate AWT support routine.</LI>
<LI>AWT generates an appropriate event object for the component in which the event occurred, and calls the component’s dispatchEvent method with the event object as a parameter.</LI>
<LI>The component’s dispatchEvent method is final, so it can’t be overridden.  It calls the object’s processEvent method which determines what kind of event has occurred, then calls the appropriate process&lt;type&gt;Event method.</LI>
<LI>The component’s process&lt;type&gt;Event method then forwards a reference to the event to each listener object which has registered itself as interested in that kind of event for the component where the event occurred.  The component maintains separate lists of interested listeners for each event type.</LI>
<LI>Because listeners have to implement as specific interface, process&lt;type&gt;Event knows exactly what method to call.</LI>
<LI>The listener object’s appropriate method, written by the application programmer, deals with the event as appropriate.</LI>
<LI>In the case of semantic events, AWT also generates a specific specialized event and dispatches it.  The component’s processEvent method knows how to handle these appropriately.</LI></OL>

<LI>Listeners and Adapters</LI>
<OL>

<LI>For each event subclass there is also an associated Listener interface, implementations of which can be registered to observe components, waiting for events of the corresponding class to occur.</LI>
<LI>Listeners are registered by add&lt;type&gt;Listener calls.  There are corresponding remove methods.</LI>
<LI>Since Listeners are interfaces, they incorporate no implementation.  This means that actual classes to implement them need to be created.  In particular, they designate the methods necessary for the delivery of event information to the listener.</LI>
<LI>There are templates for these implementing Listener classes called Adapters, and they exist for almost all Listeners.  They are templates because their method implementations are empty.</LI>
<LI>To be useful, an instance of an Adapter has to override at least one of the empty methods.  Only those methods for which the interface assigns meaning have to be overridden.  The others will maintain their empty default implementation, and thus do nothing.  A few Listeners have only one method, which <U>must</U> be overridden.  It makes no sense to create an Adapter for them.</LI>
<LI>Listeners are &quot;added&quot; to objects, and from that point on they respond by executing the appropriate methods whenever that kind of event occurs in the object.  Most often the Adapters or other Listener implementations are added during the construction of the object, but they can be added and removed at any time.</LI>
<LI>It is quite possible for an object to implement a Listener interface, so that the object itself can be registered as its own listener.</LI></OL>

<LI>Object-Oriented Design Issues</LI>
<OL>

<LI>Visual Caf&eacute; tends to create a single Listener and add it to many different components.  The body of the Listener then becomes a switch statement contingent on the object originating the event, which invokes other methods specific to the particular object.  This tends to be a sort of functional approach, where a single function handles all processing of events of a given kind.</LI>
<LI>Visual Caf&eacute; mitigates the functional approach by actually creating a matrix design.  That is, there are separate functions for different objects, and the initial Listener only tests to determine the object of origin, then dispatches control to the specific handler for that object.  In addition, version 4.0 creates separate action calls as a way to separate event handling into smaller chunks.</LI>
<LI>I don’t particularly like this way of organizing event handlers, feeling it better to generate a specific handler per event type per object. The book mentions that anonymous classes can be helpful, particularly when adding Adapters.  The idea is that we don’t have to create a separate class definition extending a Listener.  Instead, we can simply declare a new Listener or Adapter, overriding the appropriate methods inline.</LI>
<P>addMouseListener (</P>
<P>new MouseAdapter()   </P>
<P>{  public void mousePressed (MouseEvent e) </P>
<P>{</P>
<P>// do what's needed to handle the event</P>
<P>System.out.println ("Clicked at: " + e.getPoint());</P>
<P> }</P>
<P>} </P>
<P>                  );</P>
<LI>This technique reduces the cost of generating many different classes to implement handlers per component per event.</LI></OL>

<LI>Event Broadcasting and Multicasting</LI>
<OL>

<LI>It is also possible that many Listeners have been added for a single event type on a single object.  In that case, the event is sent to all of them.  In certain cases, it is possible for one handler to mark the event &quot;consumed&quot;, in which case other handlers will know that and may choose to refrain from handling the event.  The peer (underlying platform specific object) will not be aware of a consumed event. The Java system takes care of distributing events to all the Listeners interested in them.  However, there is no guarantee of the order in which individual Listeners’ methods will be called.</LI>
<LI>It may be, particularly when you have created your own events, that you want to broadcast them to a set of listeners, instead of using the Java system facilities.  This can be done through the AWTEventMulticaster class.</LI>
<OL TYPE="a">

<LI>Multicasters are lists of Listeners, but also implement all Listener interfaces themselves.</LI>
<LI>They implement Listener methods by simply passing the event to all the Listeners on the list.</LI>
<LI>There are add and remove methods, which are just like those used to add and remove Listeners for components.</LI></OL>
</OL>

<LI>The Event Queue</LI>
<OL>

<LI>If you need to manage Java events directly, you can call Toolkit.getSystemEventQueue(), which will return an EventQueue object.  There are four methods associated with this class.</LI>
<OL TYPE="a">

<LI>peekEvent returns the first event on the queue without removing it.</LI>
<LI>peekEvent(event mask) returns the first event of a particular subtype on the queue without removing it.</LI>
<LI>getNextEvent returns the first event on the queue and removes it.</LI>
<LI>postEvent places an AWTEvent on the queue</LI></OL>
</OL>
</OL>


<P>&nbsp;</P></B></BODY>
</HTML>
